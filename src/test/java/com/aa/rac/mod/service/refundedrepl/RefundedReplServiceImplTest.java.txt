package com.aa.rac.mod.service.refundedrepl;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import com.aa.rac.mod.domain.BaseService;
import com.aa.rac.mod.domain.enums.CuratedEntityClassMapper;
import com.aa.rac.mod.domain.enums.EventHubPojoClassMapper;
import com.aa.rac.mod.domain.enums.ExceptionType;
import com.aa.rac.mod.domain.enums.ServiceClassMapper;
import com.aa.rac.mod.domain.exceptions.ProcessingException;
import com.aa.rac.mod.domain.exceptions.ProcessingExceptionHandler;
import com.aa.rac.mod.domain.util.RacUtil;
import com.aa.rac.mod.orm.dao.refundedrepl.RefundedRepl;
import com.aa.rac.mod.repository.eventhub.Refunded;
import com.aa.rac.mod.repository.findatahub.refundedrepl.RefundedReplRepository;
import com.aa.rac.mod.util.AbstractTestSupport;
import com.aa.rac.mod.util.TestUtil;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.math.BigInteger;
import java.time.format.DateTimeFormatter;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import nl.altindag.log.LogCaptor;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;


/** RefundedReplServiceImpl H2 test. */
@SpringBootTest
@AutoConfigureTestDatabase
@ExtendWith(MockitoExtension.class)
@SuppressWarnings("checkstyle:LineLength")
public class RefundedReplServiceImplTest extends AbstractTestSupport {

  private final CountDownLatch lock = new CountDownLatch(1);
  private final ObjectMapper mapper = new ObjectMapper();

  DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");

  private LogCaptor logCaptor;

  @MockBean
  ProcessingExceptionHandler processingExceptionHandler;

  @Autowired 
  private RefundedReplRepository refundedReplRepository;

  @Autowired
  private BaseService<Refunded, RefundedRepl> refundedService;


  private final String insertRefunded = "{\"REF_FILE_NUMBER\":\"DBJ603\",\"REF_TICKET_NUMBER\":\"0010260403910\",\"REF_AGENCY_NUMBER\":{\"string\":\"SF1SFOTR\"},\"REF_BATCH_NUMBER\":{\"string\":\"    \"},\"REF_BATCH_DATE\":{\"string\":\"2023-07-11\"},\"REF_FOP_TYPE\":{\"string\":\"MC\"},\"REF_FOP_REFERENCE\":{\"string\":\"54XXXXXXXXXX2261\"},\"REF_REFUND_AMOUNT\":{\"string\":\"30.00\"},\"REF_RECALL_PERCENT\":{\"string\":\"0.0\"},\"REF_RECALL_AMOUNT\":{\"string\":\"0.00\"},\"REF_LAST_NAME\":{\"string\":\"SUJIPITTHAM                   \"},\"REF_FIRST_NAME\":{\"string\":\"NATTAKOR                      \"},\"REF_CHECK_DATE\":{\"string\":\"0001-01-01\"},\"REF_CHECK_RETURNED\":{\"string\":\" \"},\"REF_CHECK_CLEARED\":\"0001-01-01\",\"REF_CHECK_PROCPER\":{\"string\":\"      \"},\"REF_ID_REFUNDED\":{\"string\":\"      \"},\"REF_ENTERED_BY\":{\"string\":\"RA1289\"},\"REF_ENTERED_DATE\":{\"string\":\"2023-07-11\"},\"REF_MODIFIED_BY\":{\"string\":\"      \"},\"REF_MODIFIED_DATE\":{\"string\":\"0001-01-01\"},\"REF_STA_COPY_RECD\":\" \",\"REF_RFND_AMT_FORN\":\"0.00\",\"REF_RFND_AMT_CURCD\":\"USD \",\"REF_RECALL_AMTFORN\":\"0.00\",\"REF_RAW_TOT_CUR\":\"USD \",\"REF_EXCHANGE_RATE\":\"1.127456\",\"REF_PAYMENT_TICKET_NO\":\"0010260403910\",\"REF_PAYMENT_SERVICES\":\" \",\"REF_ORIG_RFND_AMT\":\"30.00\",\"REF_INCENT_RFND_AMT\":\"30.00\",\"REF_VCHR_TRANSACTION_ID\":\"                                                                \",\"REF_SEQUENCE_NUM\":727381,\"REF_TC_EXP_DATE\":\"0001-01-01\",\"TICKET_CREATE_TS\":\"0001-01-01T00:00:00.000000000000\",\"A_ENTTYP\":{\"string\":\"PT\"},\"A_TIMSTAMP\":{\"string\":\"2023-07-12 17:11:53.864752000000\"},\"A_USER\":{\"string\":\"AD436\"},\"A_JOBUSER\":{\"string\":\"AD436\"}}";

  private final String updateRefunded = "{\"B_REF_FILE_NUMBER\":\"DBJ603\",\"B_REF_TICKET_NUMBER\":\"0010260403910\",\"B_REF_AGENCY_NUMBER\":{\"string\":\"X25XTMWB\"},\"B_REF_BATCH_NUMBER\":{\"string\":\"22  \"},\"B_REF_BATCH_DATE\":{\"string\":\"0001-01-01\"},\"B_REF_FOP_TYPE\":{\"string\":\"VI\"},\"B_REF_FOP_REFERENCE\":{\"string\":\"43XXXXXXXXXX6855\"},\"B_REF_REFUND_AMOUNT\":{\"string\":\"16.10\"},\"B_REF_RECALL_PERCENT\":{\"string\":\"0.0\"},\"B_REF_RECALL_AMOUNT\":{\"string\":\"0.00\"},\"B_REF_LAST_NAME\":{\"string\":\"MARTINEZ                      \"},\"B_REF_FIRST_NAME\":{\"string\":\"JESUS                         \"},\"B_REF_CHECK_DATE\":{\"string\":\"0001-01-01\"},\"B_REF_CHECK_RETURNED\":{\"string\":\" \"},\"B_REF_CHECK_CLEARED\":\"0001-01-01\",\"B_REF_CHECK_PROCPER\":{\"string\":\"      \"},\"B_REF_ID_REFUNDED\":{\"string\":\"      \"},\"B_REF_ENTERED_BY\":{\"string\":\"RFA601\"},\"B_REF_ENTERED_DATE\":{\"string\":\"2023-05-17\"},\"B_REF_MODIFIED_BY\":{\"string\":\"AD490 \"},\"B_REF_MODIFIED_DATE\":{\"string\":\"2023-07-13\"},\"B_REF_STA_COPY_RECD\":\" \",\"B_REF_RFND_AMT_FORN\":\"0.00\",\"B_REF_RFND_AMT_CURCD\":\"USD \",\"B_REF_RECALL_AMTFORN\":\"0.00\",\"B_REF_RAW_TOT_CUR\":\"USD \",\"B_REF_EXCHANGE_RATE\":\"1.000000\",\"B_REF_PAYMENT_TICKET_NO\":\"0010620385491\",\"B_REF_PAYMENT_SERVICES\":\" \",\"B_REF_ORIG_RFND_AMT\":\"16.10\",\"B_REF_INCENT_RFND_AMT\":\"16.10\",\"B_REF_VCHR_TRANSACTION_ID\":\"                                                                \",\"B_REF_SEQUENCE_NUM\":692271,\"B_REF_TC_EXP_DATE\":\"0001-01-01\",\"B_TICKET_CREATE_TS\":\"2023-01-26T01:42:43.949102000000\",\"REF_FILE_NUMBER\":\"DBJ603\",\"REF_TICKET_NUMBER\":\"0010260403910\",\"REF_AGENCY_NUMBER\":{\"string\":\"X25XTMWB\"},\"REF_BATCH_NUMBER\":{\"string\":\"22  \"},\"REF_BATCH_DATE\":{\"string\":\"2023-07-13\"},\"REF_FOP_TYPE\":{\"string\":\"VI\"},\"REF_FOP_REFERENCE\":{\"string\":\"43XXXXXXXXXX6855\"},\"REF_REFUND_AMOUNT\":{\"string\":\"16.10\"},\"REF_RECALL_PERCENT\":{\"string\":\"0.0\"},\"REF_RECALL_AMOUNT\":{\"string\":\"0.00\"},\"REF_LAST_NAME\":{\"string\":\"MARTINEZ                      \"},\"REF_FIRST_NAME\":{\"string\":\"JESUS                         \"},\"REF_CHECK_DATE\":{\"string\":\"0001-01-01\"},\"REF_CHECK_RETURNED\":{\"string\":\" \"},\"REF_CHECK_CLEARED\":\"0001-01-01\",\"REF_CHECK_PROCPER\":{\"string\":\"      \"},\"REF_ID_REFUNDED\":{\"string\":\"      \"},\"REF_ENTERED_BY\":{\"string\":\"RFA601\"},\"REF_ENTERED_DATE\":{\"string\":\"2023-05-17\"},\"REF_MODIFIED_BY\":{\"string\":\"AD490 \"},\"REF_MODIFIED_DATE\":{\"string\":\"2023-07-13\"},\"REF_STA_COPY_RECD\":\" \",\"REF_RFND_AMT_FORN\":\"0.00\",\"REF_RFND_AMT_CURCD\":\"USD \",\"REF_RECALL_AMTFORN\":\"0.00\",\"REF_RAW_TOT_CUR\":\"USD \",\"REF_EXCHANGE_RATE\":\"1.000000\",\"REF_PAYMENT_TICKET_NO\":\"0010620385491\",\"REF_PAYMENT_SERVICES\":\" \",\"REF_ORIG_RFND_AMT\":\"16.10\",\"REF_INCENT_RFND_AMT\":\"16.10\",\"REF_VCHR_TRANSACTION_ID\":\"                                                                \",\"REF_SEQUENCE_NUM\":692271,\"REF_TC_EXP_DATE\":\"0001-01-01\",\"TICKET_CREATE_TS\":\"2023-01-26T01:42:43.949102000000\",\"A_ENTTYP\":{\"string\":\"UP\"},\"A_TIMSTAMP\":{\"string\":\"2023-07-13 16:09:19.098091000000\"},\"A_USER\":{\"string\":\"AD490\"},\"A_JOBUSER\":{\"string\":\"AD490\"}}";

  private final String deleteRefunded = "{\"B_REF_FILE_NUMBER\":\"DBJ603\",\"B_REF_TICKET_NUMBER\":\"0010260403910\",\"B_REF_AGENCY_NUMBER\":{\"string\":\"X25XTMWB\"},\"B_REF_BATCH_NUMBER\":{\"string\":\"    \"},\"B_REF_BATCH_DATE\":{\"string\":\"0001-01-01\"},\"B_REF_FOP_TYPE\":{\"string\":\"AX\"},\"B_REF_FOP_REFERENCE\":{\"string\":\"37XXXXXXXXX5550 \"},\"B_REF_REFUND_AMOUNT\":{\"string\":\"46.86\"},\"B_REF_RECALL_PERCENT\":{\"string\":\"0.0\"},\"B_REF_RECALL_AMOUNT\":{\"string\":\"0.00\"},\"B_REF_LAST_NAME\":{\"string\":\"SACHDEVA                      \"},\"B_REF_FIRST_NAME\":{\"string\":\"ALKA                          \"},\"B_REF_CHECK_DATE\":{\"string\":\"0001-01-01\"},\"B_REF_CHECK_RETURNED\":{\"string\":\" \"},\"B_REF_CHECK_CLEARED\":\"0001-01-01\",\"B_REF_CHECK_PROCPER\":{\"string\":\"      \"},\"B_REF_ID_REFUNDED\":{\"string\":\"      \"},\"B_REF_ENTERED_BY\":{\"string\":\"RFA601\"},\"B_REF_ENTERED_DATE\":{\"string\":\"2022-07-07\"},\"B_REF_MODIFIED_BY\":{\"string\":\"      \"},\"B_REF_MODIFIED_DATE\":{\"string\":\"0001-01-01\"},\"B_REF_STA_COPY_RECD\":\" \",\"B_REF_RFND_AMT_FORN\":\"0.00\",\"B_REF_RFND_AMT_CURCD\":\"USD \",\"B_REF_RECALL_AMTFORN\":\"0.00\",\"B_REF_RAW_TOT_CUR\":\"USD \",\"B_REF_EXCHANGE_RATE\":\"1.000000\",\"B_REF_PAYMENT_TICKET_NO\":\"0012330790153\",\"B_REF_PAYMENT_SERVICES\":\" \",\"B_REF_ORIG_RFND_AMT\":\"46.86\",\"B_REF_INCENT_RFND_AMT\":\"46.86\",\"B_REF_VCHR_TRANSACTION_ID\":\"                                                                \",\"B_REF_SEQUENCE_NUM\":483833,\"B_REF_TC_EXP_DATE\":\"0001-01-01\",\"B_TICKET_CREATE_TS\":\"2023-01-26T01:42:43.949102000000\",\"A_ENTTYP\":{\"string\":\"DL\"},\"A_TIMSTAMP\":{\"string\":\"2023-07-15 13:08:45.794346000000\"},\"A_USER\":{\"string\":\"STCUSR\"},\"A_JOBUSER\":{\"string\":\"STCUSR\"}}";

  private final String insertRefundedException = #TODO;

  @BeforeEach
  public void removeDbEntries() {
    refundedReplRepository.deleteAll();
  }

  @BeforeEach
  public void setLogCaptor() {
    logCaptor = LogCaptor.forClass(RefundedReplServiceImpl.class);
  }

  /**
   * Tests all the columns from Insert event.
   *
   * @param target RefundedRepl object
   */
  public void testInsertData(RefundedRepl target) { 
    assertEquals("DBJ603", target.getRefFileNumber(), "RefFileNumber are not equal.");
    assertEquals("0010260403910", target.getRefTicketNumber(), "RefTicketNumber are not equal.");
    assertEquals("SF1SFOTR", target.getRefAgencyNumber(), "RefAgencyNumber are not equal.");
    assertEquals(null, target.getRefBatchNumber(), "RefBatchNumber are not equal.");
    TestUtil.assertTrueTest("2023-07-11", target.getRefBatchDate(), "RefBatchDate are not equal.");
    assertEquals("MC", target.getRefFopType(), "RefFopType are not equal.");
    assertEquals("54XXXXXXXXXX2261", target.getRefFopReference(), "RefFopReference are not equal.");
    assertEquals("30.00", target.getRefRefundAmount().toString(), "RefRefundAmount are not equal.");
    assertEquals("0.0", target.getRefRecallPercent().toString(), "RefRecallPercent are not equal.");
    assertEquals("0.00", target.getRefRecallAmount().toString(), "RefRecallAmount are not equal.");
    assertEquals("SUJIPITTHAM", target.getRefLastName(), "RefLastName are not equal.");
    assertEquals("NATTAKOR", target.getRefFirstName(), "RefFirstName are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefCheckDate(), "RefCheckDate are not equal.");
    assertEquals(null, target.getRefCheckReturned(), "RefCheckReturned are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefCheckCleared(), "RefCheckCleared are not equal.");
    assertEquals(null, target.getRefCheckProcper(), "RefCheckProcper are not equal.");
    assertEquals(null, target.getRefIdRefunded(), "RefIdRefunded are not equal.");
    assertEquals("RA1289", target.getRefEnteredBy(), "RefEnteredBy are not equal.");
    TestUtil.assertTrueTest("2023-07-11", target.getRefEnteredDate(), "RefEnteredDate are not equal.");
    assertEquals(null, target.getRefModifiedBy(), "RefModifiedBy are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefModifiedDate(), "RefModifiedDate are not equal.");
    assertEquals(null, target.getRefStaCopyRecd(), "RefStaCopyRecd are not equal.");
    assertEquals("0.00", target.getRefRfndAmtForn().toString(), "RefRfndAmtForn are not equal.");
    assertEquals("USD", target.getRefRfndAmtCurcd(), "RefRfndAmtCurcd are not equal.");
    assertEquals("0.00", target.getRefRecallAmtforn().toString(), "RefRecallAmtforn are not equal.");
    assertEquals("USD", target.getRefRawTotCur(), "RefRawTotCur are not equal.");
    assertEquals("1.127456", target.getRefExchangeRate().toString(), "RefExchangeRate are not equal.");
    assertEquals("0010260403910", target.getRefPaymentTicketNo(), "RefPaymentTicketNo are not equal.");
    assertEquals(null, target.getRefPaymentServices(), "RefPaymentServices are not equal.");
    assertEquals("30.00", target.getRefOrigRfndAmt().toString(), "RefOrigRfndAmt are not equal.");
    assertEquals("30.00", target.getRefIncentRfndAmt().toString(), "RefIncentRfndAmt are not equal.");
    assertEquals(null, target.getRefVchrTransactionId(), "RefVchrTransactionId are not equal.");
    assertEquals("727381", target.getRefSequenceNum().toString(), "RefSequenceNum are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefTcExpDate(), "RefTcExpDate are not equal.");
    assertEquals("0001-01-01 00:00:00.0", target.getTicketCreateTs().toString());
  }

  /**
   * Tests all the columns from Update event.
   *
   * @param target RefundedRepl object
   */
  public void testUpdateData(RefundedRepl target) { 
    assertEquals("DBJ603", target.getRefFileNumber(), "RefFileNumber are not equal.");
    assertEquals("0010260403910", target.getRefTicketNumber(), "RefTicketNumber are not equal.");
    assertEquals("X25XTMWB", target.getRefAgencyNumber(), "RefAgencyNumber are not equal.");
    assertEquals("22", target.getRefBatchNumber(), "RefBatchNumber are not equal.");
    TestUtil.assertTrueTest("2023-07-13", target.getRefBatchDate(), "RefBatchDate are not equal.");
    assertEquals("VI", target.getRefFopType(), "RefFopType are not equal.");
    assertEquals("43XXXXXXXXXX6855", target.getRefFopReference(), "RefFopReference are not equal.");
    assertEquals("16.10", target.getRefRefundAmount().toString(), "RefRefundAmount are not equal.");
    assertEquals("0.0", target.getRefRecallPercent().toString(), "RefRecallPercent are not equal.");
    assertEquals("0.00", target.getRefRecallAmount().toString(), "RefRecallAmount are not equal.");
    assertEquals("MARTINEZ", target.getRefLastName(), "RefLastName are not equal.");
    assertEquals("JESUS", target.getRefFirstName(), "RefFirstName are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefCheckDate(), "RefCheckDate are not equal.");
    assertEquals(null, target.getRefCheckReturned(), "RefCheckReturned are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefCheckCleared(), "RefCheckCleared are not equal.");
    assertEquals(null, target.getRefCheckProcper(), "RefCheckProcper are not equal.");
    assertEquals(null, target.getRefIdRefunded(), "RefIdRefunded are not equal.");
    assertEquals("RFA601", target.getRefEnteredBy(), "RefEnteredBy are not equal.");
    TestUtil.assertTrueTest("2023-05-17", target.getRefEnteredDate(), "RefEnteredDate are not equal.");
    assertEquals("AD490", target.getRefModifiedBy(), "RefModifiedBy are not equal.");
    TestUtil.assertTrueTest("2023-07-13", target.getRefModifiedDate(), "RefModifiedDate are not equal.");
    assertEquals(null, target.getRefStaCopyRecd(), "RefStaCopyRecd are not equal.");
    assertEquals("0.00", target.getRefRfndAmtForn().toString(), "RefRfndAmtForn are not equal.");
    assertEquals("USD", target.getRefRfndAmtCurcd(), "RefRfndAmtCurcd are not equal.");
    assertEquals("0.00", target.getRefRecallAmtforn().toString(), "RefRecallAmtforn are not equal.");
    assertEquals("USD", target.getRefRawTotCur(), "RefRawTotCur are not equal.");
    assertEquals("1.000000", target.getRefExchangeRate().toString(), "RefExchangeRate are not equal.");
    assertEquals("0010620385491", target.getRefPaymentTicketNo(), "RefPaymentTicketNo are not equal.");
    assertEquals(null, target.getRefPaymentServices(), "RefPaymentServices are not equal.");
    assertEquals("16.10", target.getRefOrigRfndAmt().toString(), "RefOrigRfndAmt are not equal.");
    assertEquals("16.10", target.getRefIncentRfndAmt().toString(), "RefIncentRfndAmt are not equal.");
    assertEquals(null, target.getRefVchrTransactionId(), "RefVchrTransactionId are not equal.");
    assertEquals("692271", target.getRefSequenceNum().toString(), "RefSequenceNum are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefTcExpDate(), "RefTcExpDate are not equal.");
    assertEquals("2023-01-26 01:42:43.0", target.getTicketCreateTs().toString());
  }

  /**
   * Tests all the columns from Delete event.
   *
   * @param target RefundedRepl object
   */
  public void testDeleteData(RefundedRepl target) {
    assertEquals("DBJ603", target.getRefFileNumber(), "RefFileNumber are not equal.");
    assertEquals("0010260403910", target.getRefTicketNumber(), "RefTicketNumber are not equal.");
    assertEquals("X25XTMWB", target.getRefAgencyNumber(), "RefAgencyNumber are not equal.");
    assertEquals(null, target.getRefBatchNumber(), "RefBatchNumber are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefBatchDate(), "RefBatchDate are not equal.");
    assertEquals("AX", target.getRefFopType(), "RefFopType are not equal.");
    assertEquals("37XXXXXXXXX5550", target.getRefFopReference(), "RefFopReference are not equal.");
    assertEquals("46.86", target.getRefRefundAmount().toString(), "RefRefundAmount are not equal.");
    assertEquals("0.0", target.getRefRecallPercent().toString(), "RefRecallPercent are not equal.");
    assertEquals("0.00", target.getRefRecallAmount().toString(), "RefRecallAmount are not equal.");
    assertEquals("SACHDEVA", target.getRefLastName(), "RefLastName are not equal.");
    assertEquals("ALKA", target.getRefFirstName(), "RefFirstName are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefCheckDate(), "RefCheckDate are not equal.");
    assertEquals(null, target.getRefCheckReturned(), "RefCheckReturned are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefCheckCleared(), "RefCheckCleared are not equal.");
    assertEquals(null, target.getRefCheckProcper(), "RefCheckProcper are not equal.");
    assertEquals(null, target.getRefIdRefunded(), "RefIdRefunded are not equal.");
    assertEquals("RFA601", target.getRefEnteredBy(), "RefEnteredBy are not equal.");
    TestUtil.assertTrueTest("2022-07-07", target.getRefEnteredDate(), "RefEnteredDate are not equal.");
    assertEquals(null, target.getRefModifiedBy(), "RefModifiedBy are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefModifiedDate(), "RefModifiedDate are not equal.");
    assertEquals(null, target.getRefStaCopyRecd(), "RefStaCopyRecd are not equal.");
    assertEquals("0.00", target.getRefRfndAmtForn().toString(), "RefRfndAmtForn are not equal.");
    assertEquals("USD", target.getRefRfndAmtCurcd(), "RefRfndAmtCurcd are not equal.");
    assertEquals("0.00", target.getRefRecallAmtforn().toString(), "RefRecallAmtforn are not equal.");
    assertEquals("USD", target.getRefRawTotCur(), "RefRawTotCur are not equal.");
    assertEquals("1.000000", target.getRefExchangeRate().toString(), "RefExchangeRate are not equal.");
    assertEquals("0012330790153", target.getRefPaymentTicketNo(), "RefPaymentTicketNo are not equal.");
    assertEquals(null, target.getRefPaymentServices(), "RefPaymentServices are not equal.");
    assertEquals("46.86", target.getRefOrigRfndAmt().toString(), "RefOrigRfndAmt are not equal.");
    assertEquals("46.86", target.getRefIncentRfndAmt().toString(), "RefIncentRfndAmt are not equal.");
    assertEquals(null, target.getRefVchrTransactionId(), "RefVchrTransactionId are not equal.");
    assertEquals("483833", target.getRefSequenceNum().toString(), "RefSequenceNum are not equal.");
    TestUtil.assertTrueTest("0001-01-01", target.getRefTcExpDate(), "RefTcExpDate are not equal.");
    assertEquals("2023-01-26 01:42:43.0", target.getTicketCreateTs().toString());
  }

  /** Test insert. */
  @Test
  @DisplayName("INSERT a new record")
  public void testInsert() {
    try {

      refundedService.processAsync(insertRefunded);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Refunded refunded = mapper.readValue(insertRefunded, Refunded.class);

      String uuid = #TODO 

      Optional<RefundedRepl> refundedRepl =
          refundedReplRepository.findByRefundedUuid(uuid);
      assertNotNull(refundedRepl, "refundedRepl is null");
      assertTrue(refundedRepl.isPresent(), "No refundedRepl present");
      assertEquals(uuid, refundedRepl.get().getRefundedUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + refundedRepl.get().getRefundedUuid());
      TestUtil.assertTrueTest(
          "2023-07-12 17:11:53.864752",
          refundedRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("PT", refundedRepl.get().getDmlFlg());
      assertEquals(false, refundedRepl.get().getSrcDeletedIndicator());
      assertEquals(false, refundedRepl.get().getDeletedIndicator());

      testInsertData(refundedRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /** Test Update. */
  @Test
  @DisplayName("UPDATE an existing record")
  public void testUpdate() {
    try {

      refundedService.processAsync(insertRefunded);
      lock.await(1000, TimeUnit.MILLISECONDS);

      refundedService.processAsync(updateRefunded);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Refunded refunded = mapper.readValue(insertRefunded, Refunded.class);

      String uuid = #TODO 

      Optional<RefundedRepl> refundedRepl =
          refundedReplRepository.findByRefundedUuid(uuid);
      assertNotNull(refundedRepl, "refundedRepl is null");
      assertTrue(refundedRepl.isPresent(), "No refundedRepl present");
      assertEquals(uuid, refundedRepl.get().getRefundedUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + refundedRepl.get().getRefundedUuid());
      TestUtil.assertTrueTest(
          "2023-07-13 16:09:19.098091",
          refundedRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("UP", refundedRepl.get().getDmlFlg());
      assertEquals(false, refundedRepl.get().getSrcDeletedIndicator());
      assertEquals(false, refundedRepl.get().getDeletedIndicator());

      testUpdateData(refundedRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /** Test concurrent inserts. */
  @Test
  @DisplayName("Concurrent INSERTS throwing Exception")
  public void testConcurrentInserts() {
    try {

      refundedService.processAsync(insertRefunded);
      refundedService.processAsync(updateRefunded);
      refundedService.processAsync(deleteRefunded);
      lock.await(5000, TimeUnit.MILLISECONDS);

      Refunded refunded = mapper.readValue(insertRefunded, Refunded.class);

      String uuid = #TODO 

      Optional<RefundedRepl> refundedRepl =
          refundedReplRepository.findByRefundedUuid(uuid);
      assertNotNull(refundedRepl, "refundedRepl is null");
      assertTrue(refundedRepl.isPresent(), "No refundedRepl present");
      assertEquals(uuid, refundedRepl.get().getRefundedUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + refundedRepl.get().getRefundedUuid());

      TestUtil.assertConcurrentEvents(
          refundedRepl.get(),
          processingExceptionHandler,
          logCaptor,
          3, 0);
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /** Test concurrent updates. */
  @Test
  @DisplayName("Concurrent UPDATES throwing Exception")
  public void testConcurrentUpdates() {
    try {

      refundedService.processAsync(insertRefunded);
      lock.await(1000, TimeUnit.MILLISECONDS);

      refundedService.processAsync(updateRefunded);
      refundedService.processAsync(deleteRefunded);
      lock.await(4000, TimeUnit.MILLISECONDS);

      Refunded refunded = mapper.readValue(insertRefunded, Refunded.class);

      String uuid = #TODO 

      Optional<RefundedRepl> refundedRepl =
          refundedReplRepository.findByRefundedUuid(uuid);
      assertNotNull(refundedRepl, "refundedRepl is null");
      assertTrue(refundedRepl.isPresent(), "No refundedRepl present");
      assertEquals(uuid, refundedRepl.get().getRefundedUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + refundedRepl.get().getRefundedUuid());

      TestUtil.assertConcurrentEvents(
          refundedRepl.get(),
          processingExceptionHandler,
          logCaptor,
          2, 1);
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /** Test delete. */
  @Test
  @DisplayName("Soft DELETE existing record with src_deleted_indicator")
  public void testDelete() {
    try {

      refundedService.processAsync(insertRefunded);
      lock.await(1000, TimeUnit.MILLISECONDS);

      refundedService.processAsync(deleteRefunded);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Refunded refunded = mapper.readValue(insertRefunded, Refunded.class);

      String uuid = #TODO 

      Optional<RefundedRepl> refundedRepl =
          refundedReplRepository.findByRefundedUuid(uuid);
      assertNotNull(refundedRepl, "refundedRepl is null");
      assertTrue(refundedRepl.isPresent(), "No refundedRepl present");
      assertEquals(uuid, refundedRepl.get().getRefundedUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + refundedRepl.get().getRefundedUuid());
      TestUtil.assertTrueTest(
          "2023-07-15 13:08:45.794346",
          refundedRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("UP", refundedRepl.get().getDmlFlg());
      assertEquals(true, refundedRepl.get().getSrcDeletedIndicator());
      assertEquals(false, refundedRepl.get().getDeletedIndicator());

      testDeleteData(refundedRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

   /**
   * Event out of order with new record coming early.
   * For e.g. UPDATE comes earlier than INSERT.
   */
  @Test
  @DisplayName("Out-of-order: new UPDATE record coming early")
  public void testOutOfOrderUpdate() {
    try {

      refundedService.processAsync(updateRefunded);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Refunded refunded = mapper.readValue(updateRefunded, Refunded.class);

      String uuid = #TODO 

      Optional<RefundedRepl> refundedRepl =
          refundedReplRepository.findByRefundedUuid(uuid);
      assertNotNull(refundedRepl, "refundedRepl is null");
      assertTrue(refundedRepl.isPresent(), "No refundedRepl present");
      assertEquals(uuid, refundedRepl.get().getRefundedUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + refundedRepl.get().getRefundedUuid());
      TestUtil.assertTrueTest(
          "2023-07-13 16:09:19.098091",
          refundedRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("PT", refundedRepl.get().getDmlFlg());
      assertEquals(false, refundedRepl.get().getSrcDeletedIndicator());
      assertEquals(false, refundedRepl.get().getDeletedIndicator());

      testUpdateData(refundedRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

   /**
   * Event out of order with new record coming early.
   * For e.g. DELETE comes earlier than INSERT/UPDATE.
   */
  @Test
  @DisplayName("Out-of-order: new DELETE record coming early")
  public void testOutOfOrderDelete() {
    try {

      refundedService.processAsync(deleteRefunded);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Refunded refunded = mapper.readValue(deleteRefunded, Refunded.class);

      String uuid = #TODO 

      Optional<RefundedRepl> refundedRepl =
          refundedReplRepository.findByRefundedUuid(uuid);
      assertNotNull(refundedRepl, "refundedRepl is null");
      assertTrue(refundedRepl.isPresent(), "No refundedRepl present");
      assertEquals(uuid, refundedRepl.get().getRefundedUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + refundedRepl.get().getRefundedUuid());
      TestUtil.assertTrueTest(
          "2023-07-15 13:08:45.794346",
          refundedRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("PT", refundedRepl.get().getDmlFlg());
      assertEquals(true, refundedRepl.get().getSrcDeletedIndicator());
      assertEquals(false, refundedRepl.get().getDeletedIndicator());

      testDeleteData(refundedRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /**
   * Event out of order with older record coming later.
   * For e.g. INSERT comes later than UPDATE
   */
  @Test
  @DisplayName("Out-of-order IGNORE: Older record coming later")
  public void testIgnore() {
    try {

      refundedService.processAsync(updateRefunded);
      lock.await(1000, TimeUnit.MILLISECONDS);

      refundedService.processAsync(insertRefunded);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Refunded refunded = mapper.readValue(updateRefunded, Refunded.class);

      String uuid = #TODO 

      Optional<RefundedRepl> refundedRepl =
          refundedReplRepository.findByRefundedUuid(uuid);
      assertNotNull(refundedRepl, "refundedRepl is null");
      assertTrue(refundedRepl.isPresent(), "No refundedRepl present");
      assertEquals(uuid, refundedRepl.get().getRefundedUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + refundedRepl.get().getRefundedUuid());
      TestUtil.assertTrueTest(
          "2023-07-13 16:09:19.098091",
          refundedRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("PT", refundedRepl.get().getDmlFlg());
      assertEquals(false, refundedRepl.get().getSrcDeletedIndicator());
      assertEquals(false, refundedRepl.get().getDeletedIndicator());
      assertEquals(1,
          TestUtil.getLogMessageCountWithMessages(
              logCaptor.getInfoLogs(),
              "Current item is earlier than DB entry."));

      testUpdateData(refundedRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /** Test Exception Handling. */
  @Test
  @DisplayName("Exception Catch with Payload")
  public void testProcessingExceptionHandlerPayload() {
    try {
      refundedService.processAsync(insertRefundedException);
      lock.await(1000, TimeUnit.MILLISECONDS);
      verify(processingExceptionHandler, times(1)).handleUncaughtException(Mockito.any(), Mockito.any(), Mockito.any());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /**
   * Generates ProcessingException with given payload and additional details.
   *
   * @param payload event as string
   * @return ProcessingException with details
   */
  public ProcessingException generateProcessingException(String payload) {
    ProcessingException processingException = new ProcessingException();
    processingException.setPayload(payload);
    processingException.setCurator(null);
    processingException.setEventHubSource(null);
    processingException.setCuratedTarget(null);
    processingException.setRetryCount(1);
    return processingException;
  }

  /** Test Consume ProcessingException. */
  @Test
  @DisplayName("Consume ProcessingException")
  public void testConsumeProcessingException() {
    try {
      ProcessingException processingException = generateProcessingException(insertRefunded);

      refundedService.processAsync(processingException);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Refunded refunded = mapper.readValue(processingException.getPayload(), Refunded.class);

      String uuid = #TODO

      Optional<RefundedRepl> refundedRepl =
          refundedReplRepository.findByRefundedUuid(uuid);
      assertNotNull(refundedRepl, "refundedRepl is null");
      assertTrue(refundedRepl.isPresent(), "No refundedRepl present");
      assertEquals(uuid, refundedRepl.get().getRefundedUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + refundedRepl.get().getRefundedUuid());
      TestUtil.assertTrueTest(
          "2023-07-12 17:11:53.864752",
          refundedRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("PT", refundedRepl.get().getDmlFlg());
      assertEquals(false, refundedRepl.get().getSrcDeletedIndicator());
      assertEquals(false, refundedRepl.get().getDeletedIndicator());

      testInsertData(refundedRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }
  /** Test Exception Handling. */
  @Test
  @DisplayName("Exception Catch with ProcessingException")
  public void testProcessingExceptionHandlerProcessingException() {
    try {
      ProcessingException processingException = generateProcessingException(insertRefundedException);

      refundedService.processAsync(processingException);
      lock.await(1000, TimeUnit.MILLISECONDS);

      verify(processingExceptionHandler, times(1)).handleUncaughtException(Mockito.any(), Mockito.any(), Mockito.any());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }
}