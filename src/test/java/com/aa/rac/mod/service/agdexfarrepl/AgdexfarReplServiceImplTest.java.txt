package com.aa.rac.mod.service.agdexfarrepl;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import com.aa.rac.mod.domain.BaseService;
import com.aa.rac.mod.domain.enums.CuratedEntityClassMapper;
import com.aa.rac.mod.domain.enums.EventHubPojoClassMapper;
import com.aa.rac.mod.domain.enums.ExceptionType;
import com.aa.rac.mod.domain.enums.ServiceClassMapper;
import com.aa.rac.mod.domain.exceptions.ProcessingException;
import com.aa.rac.mod.domain.exceptions.ProcessingExceptionHandler;
import com.aa.rac.mod.domain.util.RacUtil;
import com.aa.rac.mod.orm.dao.agdexfarrepl.AgdexfarRepl;
import com.aa.rac.mod.repository.eventhub.Agdexfar;
import com.aa.rac.mod.repository.findatahub.agdexfarrepl.AgdexfarReplRepository;
import com.aa.rac.mod.util.AbstractTestSupport;
import com.aa.rac.mod.util.TestUtil;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.math.BigInteger;
import java.time.format.DateTimeFormatter;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import nl.altindag.log.LogCaptor;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;


/** AgdexfarReplServiceImpl H2 test. */
@SpringBootTest
@AutoConfigureTestDatabase
@ExtendWith(MockitoExtension.class)
@SuppressWarnings("checkstyle:LineLength")
public class AgdexfarReplServiceImplTest extends AbstractTestSupport {

  private final CountDownLatch lock = new CountDownLatch(1);
  private final ObjectMapper mapper = new ObjectMapper();

  DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");

  private LogCaptor logCaptor;

  @MockBean
  ProcessingExceptionHandler processingExceptionHandler;

  @Autowired 
  private AgdexfarReplRepository agdexfarReplRepository;

  @Autowired
  private BaseService<Agdexfar, AgdexfarRepl> agdexfarService;


  private final String insertAgdexfar = "{    \"XTD_TICKET_NO\": \"0012370339973 \",    \"XTD_FARE_CALC\": \" SYR AA X/CHI AA YYC Q20.00 221.00O8AHZSN3 AA X/CHI AA SYR Q20.00 246.00O8AHZSN1 NUC5071.00END ROE1.0 ZPORDSYRORDYYC XFORD4.5SYR4.5ORD4.5 PD25.80SQ1.29XG3.83XA6.52YC7.00XY9.402CA13.50XF                                                                              3\",    \"XTD_CREATED_BY\": \"REV7100C\",    \"XTD_CREATED_TIME\": \"2023-02-09T02: 02: 47.469141000000\",    \"XTD_MODIFIED_BY\": \"REV7100C\",    \"XTD_MODIFIED_TIME\": \"2023-02-09T02: 02: 47.469141000000\",    \"XTD_PARTITION_NBR\": 58,    \"TICKET_CREATE_TS\": \"2023-02-09T02: 02: 47.470466000000\",    \"A_ENTTYP\": {        \"string\": \"PT\"    },    \"A_TIMSTAMP\": {        \"string\": \"2023-07-11 17: 15: 19.607842000000\"    },    \"A_USER\": {        \"string\": \"AD436\"    },    \"A_JOBUSER\": {        \"string\": \"AD436\"    }}";

  private final String updateAgdexfar = "{    \"B_XTD_TICKET_NO\": \"0012370339973 \",    \"B_XTD_FARE_CALC\": \" SYR AA X/CHI AA YYC Q20.00 221.00O8AHZSN3 AA X/CHI AA SYR Q20.00 246.00O8AHZSN1 NUC5071.00END ROE1.0 ZPORDSYRORDYYC XFORD4.5SYR4.5ORD4.5 PD25.80SQ1.29XG3.83XA6.52YC7.00XY9.402CA13.50XF                                                                              3\",    \"B_XTD_CREATED_BY\": \"REV7100C\",    \"B_XTD_CREATED_TIME\": \"2023-02-09T02: 02: 47.469141000000\",    \"B_XTD_MODIFIED_BY\": \"REV7100C\",    \"B_XTD_MODIFIED_TIME\": \"2023-02-09T02: 02: 47.469141000000\",    \"B_XTD_PARTITION_NBR\": 58,    \"B_TICKET_CREATE_TS\": \"2023-02-09T02: 02: 47.470466000000\",    \"XTD_TICKET_NO\": \"0012370339973 \",    \"XTD_FARE_CALC\": \" SYR AA X/CHI AA YYC Q20.00 221.00O8AHZSN3 AA X/CHI AA SYR Q20.00 246.00O8AHZSN1 NUC5071.00END ROE1.0 ZPORDSYRORDYYC XFORD4.5SYR4.5ORD4.5 PD25.80SQ1.29XG3.83XA6.52YC7.00XY9.402CA13.50XF                                                                              3\",    \"XTD_CREATED_BY\": \"REV7100C\",    \"XTD_CREATED_TIME\": \"2023-02-09T02: 02: 47.469141000000\",    \"XTD_MODIFIED_BY\": \"REV7100C\",    \"XTD_MODIFIED_TIME\": \"2023-02-09T02: 02: 47.469141000000\",    \"XTD_PARTITION_NBR\": 58,    \"TICKET_CREATE_TS\": \"2023-02-09T02: 02: 47.470466000000\",    \"A_ENTTYP\": {        \"string\": \"PT\"    },    \"A_TIMSTAMP\": {        \"string\": \"2023-07-12 17: 15: 19.607842000000\"    },    \"A_USER\": {        \"string\": \"AD436\"    },    \"A_JOBUSER\": {        \"string\": \"AD436\"    }}";

  private final String deleteAgdexfar = "{    \"B_XTD_TICKET_NO\": \"0012370339973 \",    \"B_XTD_FARE_CALC\": \" SYR AA X/CHI AA YYC Q20.00 221.00O8AHZSN3 AA X/CHI AA SYR Q20.00 246.00O8AHZSN1 NUC5071.00END ROE1.0 ZPORDSYRORDYYC XFORD4.5SYR4.5ORD4.5 PD25.80SQ1.29XG3.83XA6.52YC7.00XY9.402CA13.50XF                                                                              3\",    \"B_XTD_CREATED_BY\": \"REV7100C\",    \"B_XTD_CREATED_TIME\": \"2023-02-09T02: 02: 47.469141000000\",    \"B_XTD_MODIFIED_BY\": \"REV7100C\",    \"B_XTD_MODIFIED_TIME\": \"2023-02-09T02: 02: 47.469141000000\",    \"B_XTD_PARTITION_NBR\": 58,    \"B_TICKET_CREATE_TS\": \"2023-02-09T02: 02: 47.470466000000\",    \"A_ENTTYP\": {        \"string\": \"DL\"    },    \"A_TIMSTAMP\": {        \"string\": \"2023-07-13 17: 15: 19.607842000000\"    },    \"A_USER\": {        \"string\": \"AD436\"    },    \"A_JOBUSER\": {        \"string\": \"AD436\"    }}";

  private final String insertAgdexfarException = #TODO;

  @BeforeEach
  public void removeDbEntries() {
    agdexfarReplRepository.deleteAll();
  }

  @BeforeEach
  public void setLogCaptor() {
    logCaptor = LogCaptor.forClass(AgdexfarReplServiceImpl.class);
  }

  /**
   * Tests all the columns from Insert event.
   *
   * @param target AgdexfarRepl object
   */
  public void testInsertData(AgdexfarRepl target) { 
    assertEquals("0012370339973", target.getXtdTicketNo(), "XtdTicketNo are not equal.");
    assertEquals("SYR AA X/CHI AA YYC Q20.00 221.00O8AHZSN3 AA X/CHI AA SYR Q20.00 246.00O8AHZSN1 NUC5071.00END ROE1.0 ZPORDSYRORDYYC XFORD4.5SYR4.5ORD4.5 PD25.80SQ1.29XG3.83XA6.52YC7.00XY9.402CA13.50XF                                                                              3", target.getXtdFareCalc(), "XtdFareCalc are not equal.");
    assertEquals("REV7100C", target.getXtdCreatedBy(), "XtdCreatedBy are not equal.");
    TestUtil.assertTimestamps("2023-02-09 02: 02: 47.4", target.getXtdCreatedTime(), formatter);
    assertEquals("REV7100C", target.getXtdModifiedBy(), "XtdModifiedBy are not equal.");
    TestUtil.assertTimestamps("2023-02-09 02: 02: 47.4", target.getXtdModifiedTime(), formatter);
    assertEquals("58", target.getXtdPartitionNbr().toString(), "XtdPartitionNbr are not equal.");
    assertEquals("2023-02-09 02: 02: 40", target.getTicketCreateTs().toString());
  }

  /**
   * Tests all the columns from Update event.
   *
   * @param target AgdexfarRepl object
   */
  public void testUpdateData(AgdexfarRepl target) { 
    assertEquals("0012370339973", target.getXtdTicketNo(), "XtdTicketNo are not equal.");
    assertEquals("SYR AA X/CHI AA YYC Q20.00 221.00O8AHZSN3 AA X/CHI AA SYR Q20.00 246.00O8AHZSN1 NUC5071.00END ROE1.0 ZPORDSYRORDYYC XFORD4.5SYR4.5ORD4.5 PD25.80SQ1.29XG3.83XA6.52YC7.00XY9.402CA13.50XF                                                                              3", target.getXtdFareCalc(), "XtdFareCalc are not equal.");
    assertEquals("REV7100C", target.getXtdCreatedBy(), "XtdCreatedBy are not equal.");
    TestUtil.assertTimestamps("2023-02-09 02: 02: 47.4", target.getXtdCreatedTime(), formatter);
    assertEquals("REV7100C", target.getXtdModifiedBy(), "XtdModifiedBy are not equal.");
    TestUtil.assertTimestamps("2023-02-09 02: 02: 47.4", target.getXtdModifiedTime(), formatter);
    assertEquals("58", target.getXtdPartitionNbr().toString(), "XtdPartitionNbr are not equal.");
    assertEquals("2023-02-09 02: 02: 40", target.getTicketCreateTs().toString());
  }

  /**
   * Tests all the columns from Delete event.
   *
   * @param target AgdexfarRepl object
   */
  public void testDeleteData(AgdexfarRepl target) {
    assertEquals("0012370339973", target.getXtdTicketNo(), "XtdTicketNo are not equal.");
    assertEquals("SYR AA X/CHI AA YYC Q20.00 221.00O8AHZSN3 AA X/CHI AA SYR Q20.00 246.00O8AHZSN1 NUC5071.00END ROE1.0 ZPORDSYRORDYYC XFORD4.5SYR4.5ORD4.5 PD25.80SQ1.29XG3.83XA6.52YC7.00XY9.402CA13.50XF                                                                              3", target.getXtdFareCalc(), "XtdFareCalc are not equal.");
    assertEquals("REV7100C", target.getXtdCreatedBy(), "XtdCreatedBy are not equal.");
    TestUtil.assertTimestamps("2023-02-09 02: 02: 47.4", target.getXtdCreatedTime(), formatter);
    assertEquals("REV7100C", target.getXtdModifiedBy(), "XtdModifiedBy are not equal.");
    TestUtil.assertTimestamps("2023-02-09 02: 02: 47.4", target.getXtdModifiedTime(), formatter);
    assertEquals("58", target.getXtdPartitionNbr().toString(), "XtdPartitionNbr are not equal.");
    assertEquals("2023-02-09 02: 02: 40", target.getTicketCreateTs().toString());
  }

  /** Test insert. */
  @Test
  @DisplayName("INSERT a new record")
  public void testInsert() {
    try {

      agdexfarService.processAsync(insertAgdexfar);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Agdexfar agdexfar = mapper.readValue(insertAgdexfar, Agdexfar.class);

      String uuid = #TODO 

      Optional<AgdexfarRepl> agdexfarRepl =
          agdexfarReplRepository.findByTicketUuid(uuid);
      assertNotNull(agdexfarRepl, "agdexfarRepl is null");
      assertTrue(agdexfarRepl.isPresent(), "No agdexfarRepl present");
      assertEquals(uuid, agdexfarRepl.get().getTicketUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + agdexfarRepl.get().getTicketUuid());
      TestUtil.assertTrueTest(
          "2023-07-11 17: 15: 19.6078",
          agdexfarRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("PT", agdexfarRepl.get().getDmlFlg());
      assertEquals(false, agdexfarRepl.get().getSrcDeletedIndicator());
      assertEquals(false, agdexfarRepl.get().getDeletedIndicator());

      testInsertData(agdexfarRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /** Test Update. */
  @Test
  @DisplayName("UPDATE an existing record")
  public void testUpdate() {
    try {

      agdexfarService.processAsync(insertAgdexfar);
      lock.await(1000, TimeUnit.MILLISECONDS);

      agdexfarService.processAsync(updateAgdexfar);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Agdexfar agdexfar = mapper.readValue(insertAgdexfar, Agdexfar.class);

      String uuid = #TODO 

      Optional<AgdexfarRepl> agdexfarRepl =
          agdexfarReplRepository.findByTicketUuid(uuid);
      assertNotNull(agdexfarRepl, "agdexfarRepl is null");
      assertTrue(agdexfarRepl.isPresent(), "No agdexfarRepl present");
      assertEquals(uuid, agdexfarRepl.get().getTicketUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + agdexfarRepl.get().getTicketUuid());
      TestUtil.assertTrueTest(
          "2023-07-12 17: 15: 19.6078",
          agdexfarRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("UP", agdexfarRepl.get().getDmlFlg());
      assertEquals(false, agdexfarRepl.get().getSrcDeletedIndicator());
      assertEquals(false, agdexfarRepl.get().getDeletedIndicator());

      testUpdateData(agdexfarRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /** Test concurrent inserts. */
  @Test
  @DisplayName("Concurrent INSERTS throwing Exception")
  public void testConcurrentInserts() {
    try {

      agdexfarService.processAsync(insertAgdexfar);
      agdexfarService.processAsync(updateAgdexfar);
      agdexfarService.processAsync(deleteAgdexfar);
      lock.await(5000, TimeUnit.MILLISECONDS);

      Agdexfar agdexfar = mapper.readValue(insertAgdexfar, Agdexfar.class);

      String uuid = #TODO 

      Optional<AgdexfarRepl> agdexfarRepl =
          agdexfarReplRepository.findByTicketUuid(uuid);
      assertNotNull(agdexfarRepl, "agdexfarRepl is null");
      assertTrue(agdexfarRepl.isPresent(), "No agdexfarRepl present");
      assertEquals(uuid, agdexfarRepl.get().getTicketUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + agdexfarRepl.get().getTicketUuid());

      TestUtil.assertConcurrentEvents(
          agdexfarRepl.get(),
          processingExceptionHandler,
          logCaptor,
          3, 0);
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /** Test concurrent updates. */
  @Test
  @DisplayName("Concurrent UPDATES throwing Exception")
  public void testConcurrentUpdates() {
    try {

      agdexfarService.processAsync(insertAgdexfar);
      lock.await(1000, TimeUnit.MILLISECONDS);

      agdexfarService.processAsync(updateAgdexfar);
      agdexfarService.processAsync(deleteAgdexfar);
      lock.await(4000, TimeUnit.MILLISECONDS);

      Agdexfar agdexfar = mapper.readValue(insertAgdexfar, Agdexfar.class);

      String uuid = #TODO 

      Optional<AgdexfarRepl> agdexfarRepl =
          agdexfarReplRepository.findByTicketUuid(uuid);
      assertNotNull(agdexfarRepl, "agdexfarRepl is null");
      assertTrue(agdexfarRepl.isPresent(), "No agdexfarRepl present");
      assertEquals(uuid, agdexfarRepl.get().getTicketUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + agdexfarRepl.get().getTicketUuid());

      TestUtil.assertConcurrentEvents(
          agdexfarRepl.get(),
          processingExceptionHandler,
          logCaptor,
          2, 1);
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /** Test delete. */
  @Test
  @DisplayName("Soft DELETE existing record with src_deleted_indicator")
  public void testDelete() {
    try {

      agdexfarService.processAsync(insertAgdexfar);
      lock.await(1000, TimeUnit.MILLISECONDS);

      agdexfarService.processAsync(deleteAgdexfar);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Agdexfar agdexfar = mapper.readValue(insertAgdexfar, Agdexfar.class);

      String uuid = #TODO 

      Optional<AgdexfarRepl> agdexfarRepl =
          agdexfarReplRepository.findByTicketUuid(uuid);
      assertNotNull(agdexfarRepl, "agdexfarRepl is null");
      assertTrue(agdexfarRepl.isPresent(), "No agdexfarRepl present");
      assertEquals(uuid, agdexfarRepl.get().getTicketUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + agdexfarRepl.get().getTicketUuid());
      TestUtil.assertTrueTest(
          "2023-07-13 17: 15: 19.6078",
          agdexfarRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("UP", agdexfarRepl.get().getDmlFlg());
      assertEquals(true, agdexfarRepl.get().getSrcDeletedIndicator());
      assertEquals(false, agdexfarRepl.get().getDeletedIndicator());

      testDeleteData(agdexfarRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

   /**
   * Event out of order with new record coming early.
   * For e.g. UPDATE comes earlier than INSERT.
   */
  @Test
  @DisplayName("Out-of-order: new UPDATE record coming early")
  public void testOutOfOrderUpdate() {
    try {

      agdexfarService.processAsync(updateAgdexfar);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Agdexfar agdexfar = mapper.readValue(updateAgdexfar, Agdexfar.class);

      String uuid = #TODO 

      Optional<AgdexfarRepl> agdexfarRepl =
          agdexfarReplRepository.findByTicketUuid(uuid);
      assertNotNull(agdexfarRepl, "agdexfarRepl is null");
      assertTrue(agdexfarRepl.isPresent(), "No agdexfarRepl present");
      assertEquals(uuid, agdexfarRepl.get().getTicketUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + agdexfarRepl.get().getTicketUuid());
      TestUtil.assertTrueTest(
          "2023-07-12 17: 15: 19.6078",
          agdexfarRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("PT", agdexfarRepl.get().getDmlFlg());
      assertEquals(false, agdexfarRepl.get().getSrcDeletedIndicator());
      assertEquals(false, agdexfarRepl.get().getDeletedIndicator());

      testUpdateData(agdexfarRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

   /**
   * Event out of order with new record coming early.
   * For e.g. DELETE comes earlier than INSERT/UPDATE.
   */
  @Test
  @DisplayName("Out-of-order: new DELETE record coming early")
  public void testOutOfOrderDelete() {
    try {

      agdexfarService.processAsync(deleteAgdexfar);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Agdexfar agdexfar = mapper.readValue(deleteAgdexfar, Agdexfar.class);

      String uuid = #TODO 

      Optional<AgdexfarRepl> agdexfarRepl =
          agdexfarReplRepository.findByTicketUuid(uuid);
      assertNotNull(agdexfarRepl, "agdexfarRepl is null");
      assertTrue(agdexfarRepl.isPresent(), "No agdexfarRepl present");
      assertEquals(uuid, agdexfarRepl.get().getTicketUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + agdexfarRepl.get().getTicketUuid());
      TestUtil.assertTrueTest(
          "2023-07-13 17: 15: 19.6078",
          agdexfarRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("PT", agdexfarRepl.get().getDmlFlg());
      assertEquals(true, agdexfarRepl.get().getSrcDeletedIndicator());
      assertEquals(false, agdexfarRepl.get().getDeletedIndicator());

      testDeleteData(agdexfarRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /**
   * Event out of order with older record coming later.
   * For e.g. INSERT comes later than UPDATE
   */
  @Test
  @DisplayName("Out-of-order IGNORE: Older record coming later")
  public void testIgnore() {
    try {

      agdexfarService.processAsync(updateAgdexfar);
      lock.await(1000, TimeUnit.MILLISECONDS);

      agdexfarService.processAsync(insertAgdexfar);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Agdexfar agdexfar = mapper.readValue(updateAgdexfar, Agdexfar.class);

      String uuid = #TODO 

      Optional<AgdexfarRepl> agdexfarRepl =
          agdexfarReplRepository.findByTicketUuid(uuid);
      assertNotNull(agdexfarRepl, "agdexfarRepl is null");
      assertTrue(agdexfarRepl.isPresent(), "No agdexfarRepl present");
      assertEquals(uuid, agdexfarRepl.get().getTicketUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + agdexfarRepl.get().getTicketUuid());
      TestUtil.assertTrueTest(
          "2023-07-12 17: 15: 19.6078",
          agdexfarRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("PT", agdexfarRepl.get().getDmlFlg());
      assertEquals(false, agdexfarRepl.get().getSrcDeletedIndicator());
      assertEquals(false, agdexfarRepl.get().getDeletedIndicator());
      assertEquals(1,
          TestUtil.getLogMessageCountWithMessages(
              logCaptor.getInfoLogs(),
              "Current item is earlier than DB entry."));

      testUpdateData(agdexfarRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /** Test Exception Handling. */
  @Test
  @DisplayName("Exception Catch with Payload")
  public void testProcessingExceptionHandlerPayload() {
    try {
      agdexfarService.processAsync(insertAgdexfarException);
      lock.await(1000, TimeUnit.MILLISECONDS);
      verify(processingExceptionHandler, times(1)).handleUncaughtException(Mockito.any(), Mockito.any(), Mockito.any());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }

  /**
   * Generates ProcessingException with given payload and additional details.
   *
   * @param payload event as string
   * @return ProcessingException with details
   */
  public ProcessingException generateProcessingException(String payload) {
    ProcessingException processingException = new ProcessingException();
    processingException.setPayload(payload);
    processingException.setCurator(ServiceClassMapper.AGDEXFARREPL_SERVICE_IMPL);
    processingException.setEventHubSource(EventHubPojoClassMapper.AGDEXFAR);
    processingException.setCuratedTarget(CuratedEntityClassMapper.AGDEXFARREPL);
    processingException.setRetryCount(1);
    return processingException;
  }

  /** Test Consume ProcessingException. */
  @Test
  @DisplayName("Consume ProcessingException")
  public void testConsumeProcessingException() {
    try {
      ProcessingException processingException = generateProcessingException(insertAgdexfar);

      agdexfarService.processAsync(processingException);
      lock.await(1000, TimeUnit.MILLISECONDS);

      Agdexfar agdexfar = mapper.readValue(processingException.getPayload(), Agdexfar.class);

      String uuid = #TODO

      Optional<AgdexfarRepl> agdexfarRepl =
          agdexfarReplRepository.findByTicketUuid(uuid);
      assertNotNull(agdexfarRepl, "agdexfarRepl is null");
      assertTrue(agdexfarRepl.isPresent(), "No agdexfarRepl present");
      assertEquals(uuid, agdexfarRepl.get().getTicketUuid(),
          "UUID: Expected=" + uuid
              + "; Actual=" + agdexfarRepl.get().getTicketUuid());
      TestUtil.assertTrueTest(
          "2023-07-11 17: 15: 19.6078",
          agdexfarRepl.get().getEventHubTimestamp(),
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSS"),
          "EventHubTimestamp are not equal");

      assertEquals("PT", agdexfarRepl.get().getDmlFlg());
      assertEquals(false, agdexfarRepl.get().getSrcDeletedIndicator());
      assertEquals(false, agdexfarRepl.get().getDeletedIndicator());

      testInsertData(agdexfarRepl.get());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }
  /** Test Exception Handling. */
  @Test
  @DisplayName("Exception Catch with ProcessingException")
  public void testProcessingExceptionHandlerProcessingException() {
    try {
      ProcessingException processingException = generateProcessingException(insertAgdexfarException);

      agdexfarService.processAsync(processingException);
      lock.await(1000, TimeUnit.MILLISECONDS);

      verify(processingExceptionHandler, times(1)).handleUncaughtException(Mockito.any(), Mockito.any(), Mockito.any());
    } catch (Exception e) {
      fail(e.getMessage(), e);
    }
  }
}